/*
 REPSS
 Copyright (C) 2012  Khalique Williams

 This file is part of REPSS.

 REPSS is free software: you can redistribute it and/or modify
 it under the terms of the   GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 REPSS is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with REPSS.  If not, see <http://www.gnu.org/licenses/>.
 */

IKeywords:obj {
@@ Done Already @@
    +reps.named_iteration { VARIABLE, RepsNamedIteration }
    +scope { VARIABLE, Scope }
    +alternation { TERMINAL, Alternation  }
    +evaluation { TERMINAL, Eval }
    +general_end { TERMINAL, End }

    +path { ../src/lib/includes/GeneratedIRecognizedKeywords.hpp }

@@ To Do @@
 @   +reps.unnamed_iteration { VARIABLE, RepsUnnamedIteration }
 @   +scope._something_ { VARIABLE, Scope_And_Something_ }
}

excerpt of what I'm gunning for:

../src/lib/includes/GeneratedIRecognizedKeywords.hpp:

            #include <vector>
            //...

            class IKeywordDefn
            {
                //...
            };

            class AbstrKeywordDefn : public IKeywordDefn
            {
                //...
            };

            class AbstrKeywords
            {
            private:
                virtual ~IKeywords() = 0;
            protected:
                class KeywordsData
                {
                private:
                    const size_t _size = 12;
                    const AbstrKeywordDefn keywords[_size] =
                      {
                        AbstrKeywordDefn{ "scope", GrammarType_t::VARIABLE },
                                                . .
                                                . .
                                                . .
                        AbstrKeywordDefn{ "general_end", GrammartType_t::TERMINAL }
                      };
                public:
                    KeywordsData() {}

                    size_t getSize() { return _size; }
                    AbstrKeywordDefn getAt(size_t index)
                    {
                        //...
                    }
                };

                const KeywordsData _data;
            public:
                template<T>
                virtual const std::vector<T> getKeywords() = 0;
            };
